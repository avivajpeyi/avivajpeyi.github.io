[{"authors":["admin"],"categories":null,"content":"I am a PhD student at Monash University where I am researching gravitational waves as a member of the LIGO collaboration. My research focuses on utilising Bayesian inference to the study gravitational waves from merging black holes. More specifically, my research is on gravitational waves from intermediate-mass black holes \u0026ndash; an elusive class of black holes that astrophysicist have yet to detect!\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1593542847,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://avivajpeyi.github.io/author/avi-vajpeyi/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/avi-vajpeyi/","section":"authors","summary":"I am a PhD student at Monash University where I am researching gravitational waves as a member of the LIGO collaboration. My research focuses on utilising Bayesian inference to the study gravitational waves from merging black holes.","tags":null,"title":"Avi Vajpeyi","type":"authors"},{"authors":[],"categories":[],"content":"Table of Contents  Interactive Jobs Jupyter notebooks + Slurm Plot CPU hours used for jobs   Interactive Jobs If you want to test softwre that requires GUI, MPI/Parallel/Multiple threads using interactive jobs may be useful. Note that if you need a GUI \u0026ndash; you\u0026rsquo;ll need to ssh with -X.\nRun the following to start an interactive job:\nsinteractive --ntasks 1 --nodes 1 --time 00:30:00 --mem 2GB  Once resources are allocated, you\u0026rsquo;ll notice that you\u0026rsquo;re on a different machine (allocated for your interactive session).\nJupyter notebooks + Slurm Once are in an interactive job session you can open a jupyter notebook with the following steps:\n  Source envs for you interactive session For example you may run the following:\nsource ~/.bash_profile module load git/2.18.0 gcc/9.2.0 openmpi/4.0.2 python/3.8.5 source venv/bin/activate    Setup tunnel + jupyter instance on cluster\nTo do this run the following:\nipnport=$(shuf -i8000-9999 -n1) ipnip=$(hostname -i) echo \u0026quot;Run on local \u0026gt;\u0026gt;\u0026gt; ssh -N -L $ipnport:$ipnip:$ipnport avajpeyi@ozstar.swin.edu.au\u0026quot; jupyter-notebook --no-browser --port=$ipnport --ip=$ipnip    Local connection to interactive job\n run the command echoed above open the link to the jupyer notebook (printed in the previous window)    Run exit when done!\nOtherwise the job will keep running until it times out.\n  For convenience I have added the following to my OzStar .bash_profile\n# Interactive Jupter notebooks alias start_ijob=\u0026quot;sinteractive --ntasks 2 --time 00:60:00 --mem 4GB\u0026quot; start_jupyter () { ipnport=$(shuf -i8000-9999 -n1) ipnip=$(hostname -i) echo \u0026quot;Run on local \u0026gt;\u0026gt;\u0026gt;\u0026quot; echo \u0026quot;ssh -N -L $ipnport:$ipnip:$ipnport avajpeyi@ozstar.swin.edu.au\u0026quot; jupcmd=$(jupyter-notebook --no-browser --port=$ipnport --ip=$ipnip) } export -f start_jupyter  Now I can start a interactive job by running start_ijob and start the jupter notebook with start_jupyter.\nPlot CPU hours used for jobs The folowing creates a file jobstats.txt that contains the CPU time (seconds) for each job run bw the start+end time specified.\nsacct -S 2021-01-01 -E 2021-10-06 -u avajpeyi -X -o \u0026quot;jobname%-40,cputimeraw\u0026quot; --parsable2 \u0026gt; jobstats.txt  To plot the data you can use the following:    Total CPU hours I\u0026rsquo;ve used (\u0026lsquo;19-\u0026lsquo;22)   ","date":1634653245,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1637293064,"objectID":"93d16828e05b93854fcb6a5e802542d6","permalink":"https://avivajpeyi.github.io/post/slurm-notes/","publishdate":"2021-10-20T00:20:45+10:00","relpermalink":"/post/slurm-notes/","section":"post","summary":"Some notes on using slurm for HPC.","tags":[],"title":"Slurm Notes","type":"book"},{"authors":[],"categories":[],"content":"Table of Contents  A Conceptual Discussion  Matched filtering in human brains Matched filtering in LIGO data   The maths  Optimal detection statistic Gaussian noise Matched-Filter   The code  Defining signals and noise Defining the matched-filtering code Examples of matched-filtering Code for demo     A Conceptual Discussion Matched filtering in human brains Human brains do a form of matched filtering when brains classify certain sounds as \u0026lsquo;words\u0026rsquo;. Eardrums are vibrated by sound waves and brains compare these sound waves to other template sound waves that are known. In the case of words, brains compare the sound waves with a bank of sound waves from learned words. This process is similar to how LIGO data analysts use matched filtering to find gravitational waves in LIGO data.\nMatched filtering in LIGO data Compact binary coalesence (CBC) searches like PyCBC use matched filtering to find gravitational wave signals in LIGO strain data. This method compares a gravitational wave template (numerical values representing one perticular gravitational wave) to strain data. Before the strain data is compared to the gravitational wave template, the data is weighed based on the detector\u0026rsquo;s sensitivity (lower the weight of the data that comes from a region where the detector is not sensitive). The output of matched-filtering is a signal-to-noise ratio (SNR) that can be used to determine if the data contains something interesting (a potential gravitational wave candidate) or just noise.\nThere are many possible gravitational wave templates (gravitational waves from CBCs can have 15 parameters that can describe them hence there are $O(n^{15})$ possible templates). To compute a matched-filter SNR for each of these templates with the LIGO data is computationally expensive. Hence, instead of match-filtering with all templates, only a subset of templates to be used in matched-filtering is selected and stored in a template bank. The bank is created to cover as much of the parameter space as possible by storing only the unique looking templates.\n  An example template bank used by LIGO searches.   The maths Optimal detection statistic The first question LIGO data analysts ask when they receive LIGO strain data $s(t)$ is:\n Does the $s(t)$ consist only of noise $n(t)$ or does $s(t)$ contain a gravitational wave signal $h(t)$ hidden in the noise?\n The two situations are two different hypotheses about the strain data:\n Null Hypothesis, $\\mathcal{H}_{n}: n(t) = s(t)$, and GW Hypothesis, $\\mathcal{H}_{GW}: n(t) = s(t) - h(t)$.   Bayes theorem can answer which of the two hypotheses are favoured by the data with an odds ratio: \\begin{equation} \\label{eq:odds} \\begin{split} \\mathcal{O}(\\mathcal{H}{GW}| s) \u0026amp; = \\frac{P(\\mathcal{H}{GW}|s)}{ P(\\mathcal{H}_{n} | s)} . \\end{split} \\end{equation}\nThis odds ratio is the optimal detection statistic that expresses the value of the probability that the data contains the anticipated signal be calculated when\n the statistical properties of the noise process are known the exact form of the signal is known  The following subsections describe in detail the statistical properties of the noise and signal that permit LIGO data analysts to calculate $\\mathcal{O}(\\mathcal{H}| s)$.\nGaussian noise To simplify the ability to make a detection, noise $n(t)$ is assumed to be [stationary Gaussian white noise]. For Gaussian white noise time series data that is sampled at regular intervals of $\\Delta t$, the probability of collecting a set of $N$ datapoints $\\vec{n}$, where $$\\vec{n} = \\{n_0(t=0), n_1(t=\\Delta t), n_2(t=2 \\Delta t), \u0026hellip;, n_{N-1}(t= (N-1) \\Delta t) \\}$$ from $0\\leq t\\leq T$, can be written as: \\begin{equation} \\label{eq:gaussian} \\begin{split} p_n(\\vec{n}) \u0026amp;= \\prod^{N-1}0 \\frac{1}{\\sigma\\sqrt{2\\pi}}\\ \\text{exp}\\left( \\frac{-1}{2\\sigma^2} n_i^2 \\right) \\\\ \u0026amp;= \\frac{1}{(\\sigma\\sqrt{2\\pi})^N}\\ \\text{exp}\\left( \\frac{-1}{2\\sigma^2} \\sum^{N-1}{i=0} n_i^2 \\right) \\end{split} \\end{equation} the following subsections delve into the maths required to simplify this.\nSumming samples For $\\lim {\\Delta t \\to 0}$, $\\sum^{N}_{i=1} n_i^2$ turns into an integral:\n\\begin{equation} \\label{eq:gauss_limit} \\begin{split} \\lim_{\\Delta t \\to 0} \\sum^{N}{i=1} n_i^2 \\Delta t \u0026amp;= \\int^T_0 n^2(t) dt \\\\ \u0026amp;= \\text{(Parseval\u0026rsquo;s Theorem and assume $0 \\to T$ very large?)} \\\\ \u0026amp;\\approx \\int^{-\\infty}{+\\infty} |\\widetilde{n}(f)|^2 df \\end{split} \\end{equation}\nAutocorrelation function for Gaussian Noise Additionally, as $\\lim {\\Delta t \\to 0}$, we can also get an expression for the autocorrelation function.\n Autocorrelation Function:\nThe autocorrelation function is a tools used to find patterns in time-series data. There are two types:\n Ensemble autocorrelation: quantifies correclation between points after repeated trials Temporal autocorrelation: quantifies correlation between points separated by various time lags in the same time-series  As points become more separated, typically the temporal autocorrelation function should go to 0 (since it is difficult to to forecast further into the future from a given set of data).\nFor a continuous-time signal $y(t)$ and a lag of $\\tau$, the temporal autocorreclation $R^T_{yy}(\\tau)$ is given by: $$ R^T_{yy}(\\tau) = \\int^{+\\infty}{-\\infty} y(t) y^*(t-\\tau)\\ ,$$ and the ensemble autocorrelation $R^E{yy}(\\tau)$ is given by: $$ R^E_{yy}(\\tau) = \\langle y(t)|y(t-\\tau)\\rangle. $$\nIf the signal is erodic (ie the signal\u0026rsquo;s statistical properties can be deduced from a long set of random samples), then $$ R^T_{yy}(\\tau) =\\lim_{T\\to \\infty} \\frac{1}{T} \\int^{T}{0} y(t) y^*(t-\\tau)dt = R^E{yy}(\\tau) .$$\nFinally, note that the units ot $R$ are that of power! Hence, this can be used in the calculation of a power spectral density.\n  At $\\lim {\\Delta t \\to 0}$, the autocorrelation function for $n(t)$ becomes \\begin{equation} \\label{eq:gauss_autocorrelation_temporal} \\begin{split} R^T_{nn}(\\tau=\\Delta t) \u0026amp;= \\lim_{T\\to \\infty} \\frac{1}{T} \\int^{T}{0} n(t) n^*(t-\\Delta t)dt \\\\ \u0026amp;= \\lim{T\\to \\infty} \\frac{1}{T} \\int^{T}_{0} |n(t)|^2 dt \\\\ \u0026amp;= A\\delta(\\tau) \\end{split} \\end{equation}\nTo determine $A$, we need to consider $R^E_{nn}$. Note for a random process $x(\\theta)$, $$ \\langle x(\\theta)|x(\\theta) \\rangle = \\mu$$ $$ \\langle (x(\\theta)-\\mu)^2| (x(\\theta)-\\mu)^2 \\rangle = \\sigma^2$$ Hence, for Gaussian white noise where $\\mu=0$,\n\\begin{equation} \\label{eq:gauss_autocorrelation_ensemble} \\begin{split} \\sigma^2 \u0026amp;= \\langle (n(t)-\\mu)^2| (n(t)-\\mu)^2 \\rangle\\rangle \\\\ \u0026amp;= \\langle n^2(t)| n^2(t) \\rangle\\rangle \\\\ \u0026amp;= R^E_{nn}(\\tau) \\\\ \u0026amp;= A \\end{split} \\end{equation}\nThus, $$R_{nn}(\\tau)=\\sigma^2\\delta(\\tau) $$\nPower spectral density from autocorrelation The one-sided power spectral density $\\text{PSD}(f)$ (of a signal $n(t)$) is defined as twice the Fourier transform of the noise autocorrelation function: \\begin{equation} \\label{eq:psd_calc} \\begin{split} \\text{PSD}(f) \u0026amp;= 2 \\mathcal{F}(R_{nn}(t))) \\\\ \u0026amp;= 2 \\int_{-\\infty}^{+\\infty}R_{nn}(\\tau) e^{-if\\tau}d\\tau \\end{split} \\end{equation}\n Derivation of the above PSD equation (taken from Mike Lau\u0026rsquo;s master\u0026rsquo;s thesis) \\begin{equation} \\label{eq:psd_derivation} \\begin{split} \\mathcal{F}(R_{nn}(t))) \u0026amp;= \\langle \\tilde{n}^*(f) \\tilde{n}(f')\\rangle\\\\ \u0026amp;= \\iint^{\\infty}{-\\infty} \\langle {n}(t) {n}(t')\\rangle e^{-2\\pi i (ft-f\u0026rsquo;t')} dt dt'\\\\ \u0026amp;{t'\\to t+t'}\\\\ \u0026amp;=\\iint^{\\infty}{-\\infty} \\langle {n}(t) {n}(t+t')\\rangle e^{-2\\pi i(f-f')t} e^{-2\\pi if\u0026rsquo;t'} dt dt'\\\\ \u0026amp;=\\int^{\\infty}_{-\\infty} \\langle {n}(t) {n}(t+t')\\rangle e^{-2\\pi if\u0026rsquo;t'} dt' \\delta(f-f') \\\\ \u0026amp;= \\frac{1}{2}\\text{PSD}(f)\\delta(f-f') \\\\ \\end{split} \\end{equation}   In the case where $\\lim {\\Delta t \\to 0}$, $$R_{nn}(\\tau)=\\sigma^2\\delta(\\tau) = R_{nn}(f), $$ hence, $$\\text{PSD}(f) = \\lim_{\\Delta t \\to 0} 2\\sigma^2 \\Delta t$$\nGaussian noise at $\\lim {\\Delta t \\to 0}$ Finally, putting the above together, the probability of collecting a set of $N$ datapoints $\\vec{n}$ from Guassian white noise is simplified to: \\begin{equation} \\label{eq:gaussian_prob} \\begin{split} p_n(\\vec{n}) \u0026amp;= \\lim_{\\Delta t \\to 0}\\frac{1}{(\\sigma\\sqrt{2\\pi})^N}\\ \\text{exp}\\left( \\frac{-1}{2\\sigma^2} \\sum^{N-1}{i=0} n_i^2\\right) \\\\ \u0026amp;\\propto \\lim{\\Delta t \\to 0} \\text{exp}\\left( \\frac{-1}{2\\sigma^2\\Delta t} \\sum^{N-1}{i=0} n_i^2 \\Delta t\\right) \\\\ \u0026amp;\\propto \\text{exp}\\left( \\frac{-1}{\\text{PSD}(f)} \\int^{T}{0} n(t)^2 dt\\right) \\\\ \u0026amp;\\propto \\text{exp}\\left( - \\int^{\\infty}{-\\infty} \\frac{|n(f)|^2}{\\text{PSD}(f)} df\\right) \\\\ \u0026amp;\\propto \\text{exp}\\left(-\\frac{1}{2} 4 \\int^{\\infty}{0} \\frac{|n(f)|^2}{\\text{PSD}(f)} df\\right) \\\\ \\therefore p_n(\\vec{n}) \u0026amp;\\propto \\text{e}^{-(n,n)/2} \\end{split} \\end{equation}\n **Noise Weighted Inner product of two time-series ** The noise weighted inner product $(a,b)$ of two time-series $a(t)$ and $b(t)$ is defined as \\begin{equation} \\label{eq:inner_producs} \\begin{split} (a,b) \u0026amp;= 4 \\text{Re} \\int_0^{\\infty} \\frac{\\tilde{a}(f) \\tilde{b}^(f)}{\\text{PSD}(f)}df\\\\ \u0026amp;= 2 \\int_{-\\infty}}^{\\infty} \\frac{\\tilde{a}(f) \\tilde{b}^(f)}{\\text{PSD}(|f|)}df\\\\ \u0026amp;= \\int_{-\\infty}}^{\\infty} \\frac{\\tilde{a}(f) \\tilde{b}^(f) + \\tilde{a}^(f) \\tilde{b}(f)}{\\text{PSD}(|f|)}df, \\end{split} \\end{equation}   where\n $\\text{PSD}(f) is the one-sided power spectral density of noise, and $\\tilde{y}(-f) = \\tilde{y}^*(f)$ .  Matched-Filter The above section provides a mathematical perscription to calculate the probability desnsity that a collection of time-series data comes from stationary Gaussian white noise. Using this, the probability density of getting some data given $\\matchcal{H}{n}$ and the probability density of getting some data given $\\matchcal{H}{GW}$ can be calculated:\n $p(s|\\mathcal{H}_{n}:n=s) \\propto \\text{e}^{-(s,s)/2}$ $p(s|\\mathcal{H}_{GW}:s=s-h) \\propto \\text{e}^{-(s-h,s-h)/2}$  Finally, going off of the odd\u0026rsquo;s ratio, we can calculate a likelihood ratio:\n\\begin{equation} \\label{eq:likelihood_ratio} \\begin{split} \\Lambda(\\mathcal{H}{GW}| s) \u0026amp;= \\frac{p(s|\\mathcal{H}{GW}|s)}{ p(s|\\mathcal{H}_{n})} \\\\ \u0026amp;= \\frac{\\text{e}^{-(s-h,s-h)/2}}{\\text{e}^{-(s,s)/2} \\\\ \u0026amp;= \\text{e}^{(s,h)}\\text{e}^{-(h,h)/2} \\end{split} \\end{equation}\nNote that:\n $\\Lambda(\\mathcal{H}_{GW}| s)$ depends on the data $s(t)$ only through $(s, h)$ $\\Lambda(\\mathcal{H}_{GW}| s)$ is a monotonically increasing function of this $(s, h)$.  $\\therefore (s,h)$ is the optimal detection statistic: any choice of threshold on the required odds ratio for accepting the alternative hypothesis can be translated to a threshold on the value of $(s, h)$. This inner produc is the matched filter since it is a noise-weighted correlation of the anticipated signal with the data.\nThe code As discussed above, one method of searching for a specific signal in a noisy data is via a matched filter. The code for this is illustrated in this section.\nDefining signals and noise Here is the python code to generate Gaussain pulses, square pulses and noise.\ndef get_gaussian_pulse_signal(time: np.ndarray) -\u0026gt; np.ndarray: sig = scipy.signal.gausspulse(t=time, fc=5) sig[np.abs(sig) \u0026lt; 1e-2] = 0 return sig def get_square_pulse_signal(time: np.ndarray) -\u0026gt; np.ndarray: idx_to_one = np.abs(time) \u0026lt;= 0.5 sig = np.array([1 if one else 0 for one in idx_to_one]) return sig def get_noise(time: np.ndarray, noise_factor: Optional[float] = 2) -\u0026gt; np.ndarray: noise = np.random.randn(1, len(time)) * noise_factor return noise[0]  The data generated from Gaussian noise and a Gaussian Pulse signal is shown in the following image.   A demonstrative image showing what happens to a Gaussian Pulse signal when some noise is added to it.   Defining the matched-filtering code Here is a rudimentary implementation of a matched-filter method, where the data is multiplied with the template, and the convolution is summed.\ndef perform_matched_filter( time: np.ndarray, data: np.ndarray, template_func: Callable ) -\u0026gt; Dict: match_filter_values = [] template = move_template_to_lowest_time(t=template_func(time)) for i in range(0, len(data), 10): current_template = np.roll(template, shift=i) matched_filter = sum(data * current_template) match_filter_values.append(dict( matched_filter=matched_filter, time=time[i], template=current_template )) return match_filter_values  Examples of matched-filtering Finding a Gaussian Pulse with a Gaussian Pulse Template   Finding a Gaussian Pulse with a Square Template   Finding a Square with a Gaussian Pulse Template   Code for demo The entire code for the demo can be found here:  ","date":1593354045,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593583659,"objectID":"97b532b864bcd6a7264fb3297db87cc2","permalink":"https://avivajpeyi.github.io/post/matched-filtering/","publishdate":"2020-06-29T00:20:45+10:00","relpermalink":"/post/matched-filtering/","section":"post","summary":"Matched filtering in LIGO data analysis","tags":[],"title":"Matched Filtering","type":"post"},{"authors":[],"categories":[],"content":"Here are some of my note written on OneNote:\n         ","date":1593354045,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1603671554,"objectID":"54718db293cbf6dbde4bfdc3004aea0f","permalink":"https://avivajpeyi.github.io/post/understanding-exoplanet-transits/","publishdate":"2020-06-29T00:20:45+10:00","relpermalink":"/post/understanding-exoplanet-transits/","section":"post","summary":" ","tags":[],"title":"Understanding exoplanet transits","type":"post"},{"authors":[],"categories":[],"content":"","date":1592492452,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"14266804c6b6b3bc94e6fc026555241d","permalink":"https://avivajpeyi.github.io/project/glass-runner/","publishdate":"2020-06-19T01:00:52+10:00","relpermalink":"/project/glass-runner/","section":"project","summary":"Help Glass Runner avoid being shattered by the moving blocks!","tags":["game","proc-gen"],"title":"Glass Runner","type":"project"},{"authors":[],"categories":[],"content":"   20 colorblind cols. Note the colors are very similar after ~10.   ","date":1592490045,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593542847,"objectID":"a708e7c329a124fdfb209dd34305b553","permalink":"https://avivajpeyi.github.io/post/colorblind-palette-for-plotting/","publishdate":"2020-06-19T00:20:45+10:00","relpermalink":"/post/colorblind-palette-for-plotting/","section":"post","summary":"Choosing colors is a pain. This snippet helps choose colors.","tags":[],"title":"Colorblind Palette for Plotting","type":"post"},{"authors":[],"categories":[],"content":"What are the Big-O for the following? Some students in an Algorithms class I am teaching are having trouble with Big-O notation. Here are some practice problems:\nQs 1 for i in range(n): sum++  Answer O(n)   Qs 2 for i in range(n) for j in range(n) sum+=1  Answer O(n)   Qs 3 for i in range(n, - 1, -1): sum +=1  Answer O(n^2)   Qs 4 i = 1 while i\u0026lt;n: i *= 2  Answer O(2^n)   Qs 5 i = n while (i \u0026lt; n) i ++  Answer O(1)   Qs 6 def fibonacci(n): if (n \u0026lt;= 1): return n else: return(fibonacci(n - 2) + fibonacci(n -1))  Answer O(2^n)   Qs 7 i = 0 while (i \u0026gt; n) i *= 2  Answer O(1)   Qs 8 for(int i=n; i\u0026gt;0; i/=2) for(int j=0; j\u0026lt;i; j++) count++;  Answer O(n)   Qs 9 for(int i=1; i\u0026lt;n*n; i++) for(int j=1; j≤i; j++) for(int k=1; k≤ 6; k++) sum ++;  Answer O(n^4)   ","date":1592490045,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592624423,"objectID":"fe80909b58604a0168f97cf04e171879","permalink":"https://avivajpeyi.github.io/post/python-big-o-examples/","publishdate":"2020-06-19T00:20:45+10:00","relpermalink":"/post/python-big-o-examples/","section":"post","summary":"Exaples of Big-O code snippets","tags":[],"title":"Python Big-O Examples","type":"post"},{"authors":[],"categories":[],"content":"","date":1592488566,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"3d633a3242856572b6d3292d5dfb366d","permalink":"https://avivajpeyi.github.io/project/tunnel-vision/","publishdate":"2020-06-18T23:56:06+10:00","relpermalink":"/project/tunnel-vision/","section":"project","summary":"Fly your aircraft through the procedurally generated tunnels.","tags":["game","proc-gen"],"title":"Tunnel Vision","type":"project"},{"authors":[],"categories":[],"content":"","date":1592488557,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"0d60045db3a8f5af3919fd2b391fdb61","permalink":"https://avivajpeyi.github.io/project/boogie-block/","publishdate":"2020-06-18T23:55:57+10:00","relpermalink":"/project/boogie-block/","section":"project","summary":"All my colours were stripped away!  Help me become fabulous again by rollin' me around the block.","tags":["game"],"title":"Boogie Block","type":"project"},{"authors":[],"categories":[],"content":"","date":1592488549,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"9a5c7c12f71cfd4019ecf1144888b734","permalink":"https://avivajpeyi.github.io/project/vitality/","publishdate":"2020-06-18T23:55:49+10:00","relpermalink":"/project/vitality/","section":"project","summary":"Sacrifice your health to gain the power you need to survive against the uprising of cuboid shapes!","tags":["game"],"title":"Vitality","type":"project"},{"authors":[],"categories":[],"content":"","date":1592488540,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"47afbc68e9208fb5b3dc7b7adb790a8e","permalink":"https://avivajpeyi.github.io/project/chain-game/","publishdate":"2020-06-18T23:55:40+10:00","relpermalink":"/project/chain-game/","section":"project","summary":"Use your dead-eye to lock on and zoom into your targets.","tags":["game"],"title":"Chain Game","type":"project"},{"authors":[],"categories":[],"content":"","date":1592488519,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"3bf61a207a3662af37b49075dd3d4637","permalink":"https://avivajpeyi.github.io/project/taxi-tank/","publishdate":"2020-06-18T23:55:19+10:00","relpermalink":"/project/taxi-tank/","section":"project","summary":"The streets of India can be a chaotic place. Fearlessly navigate the streets of the city in your tank - but watch out for the enemies.","tags":["game"],"title":"Taxi Tank","type":"project"},{"authors":[],"categories":[],"content":"","date":1592488513,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"4110ff6a54a3c76e610f2567ef55d765","permalink":"https://avivajpeyi.github.io/project/move-it/","publishdate":"2020-06-18T23:55:13+10:00","relpermalink":"/project/move-it/","section":"project","summary":"Shout 'left' or 'right' to move your character from falling lava! Watch out – if the entire floor becomes lava, its game over!","tags":["game"],"title":"Move It","type":"project"},{"authors":[],"categories":[],"content":"","date":1592488506,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"12de580ea1c03e23f08616e1cc3f81c7","permalink":"https://avivajpeyi.github.io/project/soul-collector/","publishdate":"2020-06-18T23:55:06+10:00","relpermalink":"/project/soul-collector/","section":"project","summary":"You, The PoPo, have one job: to 'collect' the souls of the cursed with the help of your car.","tags":["game"],"title":"Soul Collector","type":"project"},{"authors":[],"categories":[],"content":"","date":1592452787,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"8187c82d7bbb5d50d82735ccd80fc8ae","permalink":"https://avivajpeyi.github.io/project/time-turner/","publishdate":"2020-06-18T13:59:47+10:00","relpermalink":"/project/time-turner/","section":"project","summary":"A turn-based driving evasion game.","tags":["game"],"title":"Time Turner","type":"project"},{"authors":["I.~M. Romero-Shaw","C. Talbot","S. Biscoveanu","V. D'Emilio","G. Ashton","C.~P.~L. Berry","S. Coughlin","S. Galaudage","C. Hoy","M. Huebner","K.~S. Phukon","M. Pitkin","M. Rizzo","N. Sarin","R. Smith","S. Stevenson","A. Vajpeyi","M. Arene","K. Athar","S. Banagiri","N. Bose","M. Carney","K. Chatziioannou","R. Cotesta","B. Edelman","C. Garcia-Quiros","Abhirup Ghosh","R. Green","C. -J. Haster","A.~X. Kim","F. Hernandez-Vivanco","I. Magana Hernandez","C. Karathanasis","P.~D. Lasky","N. De Lillo","M.~E. Lower","D. Macleod","M. Mateu-Lucena","A. Miller","M. Millhouse","S. Morisaki","S.~H. Oh","S. Ossokine","E. Payne","J. Powell","M. Puerrer","A. Ramos-Buades","V. Raymond","E. Thrane","J. Veitch","D. Williams","M.~J. Williams","L. Xiao"],"categories":null,"content":"","date":1590969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"406a261f19444ed1dc5e421b6666b8e5","permalink":"https://avivajpeyi.github.io/publication/content/publication/2020-ar-xiv-200600714-r/","publishdate":"2020-06-18T13:29:00.137881Z","relpermalink":"/publication/content/publication/2020-ar-xiv-200600714-r/","section":"publication","summary":"","tags":["Astrophysics - Instrumentation and Methods for Astrophysics","General Relativity and Quantum Cosmology"],"title":"Bayesian inference for compact binary coalescences with BILBY: Validation and application to the first LIGO--Virgo gravitational-wave transient catalogue","type":"publication"},{"authors":[],"categories":[],"content":"For my PhD canditure I have to produce some reports documenting my progress:\n 6 months: Initial Project Review Report 12 months: Confirmation Report  Note: to view these documents you may have to click on \u0026ldquo;Advanced \u0026gt; Proceed\u0026rdquo;.\n","date":1586442045,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593542847,"objectID":"fa203222d88feaeef7a8d2bf4afd0114","permalink":"https://avivajpeyi.github.io/post/phd-reports/","publishdate":"2020-04-10T00:20:45+10:00","relpermalink":"/post/phd-reports/","section":"post","summary":"Links to my canditure reports","tags":[],"title":"PhD Reports","type":"post"},{"authors":[],"categories":[],"content":"Steps Step 0: Requirements Module loads/things you might need:\nmodule load git/2.18.0 module load git-lfs/2.4.0 module load anaconda3/5.1.0 module load gcc/6.4.0 module load openmpi/3.0.0 module load fftw/3.3.7 module load swig/3.0.12-python-3.6.4 module load framel/8.30 module load metaio/8.4.0 module load gsl/2.4  Step 1: Install lal git clone git@git.ligo.org:lscsoft/lalsuite.git mkdir lal_install_dir cd lalsuite/lal ./00boot \u0026amp;\u0026amp; ./configure --prefix=/\u0026lt;path to\u0026gt;/lal_install_dir/ \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install . \u0026lt;path to\u0026gt;/lal_install_dir/etc/lal-user-env.sh  Step 2: Install lalsimulation cd ../lalsimulation ./00boot \u0026amp;\u0026amp; ./configure --prefix=/\u0026lt;path to\u0026gt;/lal_install_dir/ \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install \u0026lt;path to\u0026gt;/lal_install_dir/etc/lalsimulation-user-env.sh  At this point, the installation should(?) work. Test it out in python:\ncd ~ python \u0026gt;\u0026gt;\u0026gt; import lalsimulation  Step 3: Get waveform data cd ~/ \u0026amp; mkdir waveform_data echo \u0026quot;export LAL_DATA_PATH=/\u0026lt;path_to_wave_data_dir\u0026gt;\u0026quot; \u0026gt;\u0026gt; .bash_profile  Copy the waveform data files and place them into this the waveform_data/ dir\n Where do we get the waveform datafiles from again?   Test install with the following script  ","date":1568816445,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593583704,"objectID":"89ddb6e8386cf22cc6f154259950a624","permalink":"https://avivajpeyi.github.io/post/installing-lalsuite-from-source/","publishdate":"2019-09-19T00:20:45+10:00","relpermalink":"/post/installing-lalsuite-from-source/","section":"post","summary":"Source installing LalSuite sucks. Here are instructions that have worked for me.","tags":[],"title":"Installing LalSuite from Source","type":"post"},{"authors":["Rory Smith","Gregory Ashton","Avi Vajpeyi","Colm Talbot"],"categories":null,"content":"","date":1567296e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"0296ebe9187471d1e1f82e6989210e87","permalink":"https://avivajpeyi.github.io/publication/content/publication/2019-ar-xiv-190911873-s/","publishdate":"2020-06-18T13:29:00.138635Z","relpermalink":"/publication/content/publication/2019-ar-xiv-190911873-s/","section":"publication","summary":"","tags":["General Relativity and Quantum Cosmology","Astrophysics - Instrumentation and Methods for Astrophysics"],"title":"Massively parallel Bayesian inference for transient gravitational-wave astronomy","type":"publication"},{"authors":["Maximiliano Isi","Rory Smith","Salvatore Vitale","T.~J. Massinger","Jonah Kanner","Avi Vajpeyi"],"categories":null,"content":"","date":1533081600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592493788,"objectID":"b0e4779a8bfc700c5d1034bc5f8ff93b","permalink":"https://avivajpeyi.github.io/publication/content/publication/2018-ph-rv-d-98-d-2007-i/","publishdate":"2020-06-18T13:29:00.136569Z","relpermalink":"/publication/content/publication/2018-ph-rv-d-98-d-2007-i/","section":"publication","summary":"","tags":["General Relativity and Quantum Cosmology","Astrophysics - High Energy Astrophysical Phenomena","Physics - Data Analysis","Statistics and Probability"],"title":"Enhancing confidence in the detection of gravitational waves from compact binaries using signal coherence","type":"publication"}]